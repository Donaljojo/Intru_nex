<?php

namespace App\\Modules\\VulnerabilityDetection\\Service;

use App\\Modules\\AssetDiscovery\\Entity\\Asset;
use App\\Modules\\AssetVulnerability\\Entity\\Vulnerability;
use App\\Modules\\ScanManagement\\Entity\\ScanJob;
use Doctrine\\ORM\\EntityManagerInterface;
use Psr\\Log\\LoggerInterface;
use Symfony\\Component\\Process\\Exception\\ProcessFailedException;
use Symfony\\Component\\Process\\Process;

class NiktoScanService
{
    private EntityManagerInterface $em;
    private LoggerInterface $logger;
    private string $niktoBinary;

    public function __construct(EntityManagerInterface $em, LoggerInterface $logger, string $niktoBinary = 'nikto')
    {
        $this->em = $em;
        $this->logger = $logger;
        $this->niktoBinary = $niktoBinary;
    }

    public function scan(Asset $asset, ScanJob $scanJob): ScanJob
    {
        $target = $asset->getUrl() ?? $asset->getIpAddress() ?? $asset->getDomain();

        if (!$target) {
            throw new \RuntimeException('No valid target found for asset: ' . $asset->getId());
        }

        $this->logger->info("Starting Nikto scan for: {$target}");

        // ğŸ”¹ Create a temporary JSON output file
        $outputFile = sys_get_temp_dir() . '/nikto_' . uniqid() . '.json';

        // âœ… Correct command: include -output filename
        $process = new Process([
            $this->niktoBinary,
            '-h', $target,
            '-Format', 'json',
            '-output', $outputFile
        ]);
        $process->setTimeout(600);
        $process->run();

        if (!$process->isSuccessful()) {
            throw new ProcessFailedException($process);
        }

        // ğŸ”¹ Read JSON output from file
        if (!file_exists($outputFile)) {
            throw new \RuntimeException('Nikto scan did not produce an output file.');
        }

        $jsonText = file_get_contents($outputFile);
        unlink($outputFile); // clean up temp file

        $decoded = json_decode($jsonText, true);
        if ($decoded === null) {
            throw new \RuntimeException('Failed to decode Nikto JSON output. Raw output: ' . substr($jsonText, 0, 300));
        }

        $findings = $this->parseNiktoJson($decoded);

        // ğŸ”¹ Store vulnerabilities
        foreach ($findings as $f) {
            $existingVulnerability = $this->em->getRepository(Vulnerability::class)->findOneBy([
                'asset' => $asset,
                'description' => $f['msg'] ?? 'No description',
            ]);

            if (!$existingVulnerability) {
                $vuln = new Vulnerability();
                $vuln->setAsset($asset);
                $vuln->setCveId($f['id'] ?? null);
                $vuln->setDescription($f['msg'] ?? 'No description');
                $vuln->setSeverity($f['severity'] ?? 'Medium');
                $vuln->setStatus('Open');
                $vuln->setDiscoveredAt(new \DateTimeImmutable());

                $this->em->persist($vuln);
            }
        }

        $this->em->flush();

        $this->logger->info("Nikto scan completed for: {$target} with " . count($findings) . " findings.");

        return $scanJob;
    }

    private function parseNiktoJson(array $decoded): array
    {
        $results = [];

        foreach ($decoded as $hostData) {
            if (isset($hostData['vulnerabilities']) && is_array($hostData['vulnerabilities'])) {
                foreach ($hostData['vulnerabilities'] as $vuln) {
                    $results[] = [
                        'id' => $vuln['id'] ?? null,
                        'msg' => $vuln['msg'] ?? '',
                        'url' => $vuln['url'] ?? '',
                        'severity' => $this->determineSeverity($vuln['msg'] ?? ''),
                    ];
                }
            }
        }

        return $results;
    }

    private function determineSeverity(string $msg): string
    {
        $msg = strtolower($msg);
        if (str_contains($msg, 'critical') || str_contains($msg, 'vulnerability')) {
            return 'High';
        }
        if (str_contains($msg, 'missing') || str_contains($msg, 'not set')) {
            return 'Medium';
        }
        return 'Low';
    }
}



